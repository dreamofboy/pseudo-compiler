pub mod expression;
pub mod statement;

use crate::parser::statement::Statement;
use crate::parser::expression::Expression;
use crate::lexer::tokens::Token;
use crate::Result;

use std::vec::IntoIter;
use peek_nth::PeekableNth;

/// [`Token`] Iterator type generated by the [`Lexer`].
///
/// [`Token`]: crate::lexer::tokens::Token
/// [`Lexer`]: crate::lexer::Lexer
type TokenIter = PeekableNth<IntoIter<Token>>;

/// An RDP (Recursive Descent Parser) which generates an AST (Abstract Syntax Tree)
pub struct Parser {
    /// [`Token`] Iterator generated by the [`Lexer`].
    ///
    /// [`Token`]: crate::lexer::tokens::Token
    /// [`Lexer`]: crate::lexer::Lexer
    pub tokens: TokenIter,
}

impl Parser {
    pub fn new(tokens: TokenIter) -> Self {
        Parser {
            tokens,
        }
    }

    pub fn parse(&mut self) -> Result<Statement> {
        self.parse_statement()
    }
}



